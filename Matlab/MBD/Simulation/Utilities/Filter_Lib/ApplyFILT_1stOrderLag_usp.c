/*
 * File: ApplyFILT_1stOrderLag_usp.c
 *
 *
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is an S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_defines_Changes_BEGIN
  *        #define NAME 'replacement text' 
  *        %%% SFUNWIZ_defines_Changes_END
  *
  *   DO NOT change NAME--Change the 'replacement text' only.
  *
  *   For better compatibility with the Simulink Coder, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Simulink Coder's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *  -------------------------------------------------------------------------
  * | See matlabroot/simulink/src/sfuntmpl_doc.c for a more detailed template |
  *  ------------------------------------------------------------------------- 
 * Created: Mon Feb 18 15:17:13 2013
 * 
 *
 */

#define S_FUNCTION_LEVEL 2
#define S_FUNCTION_NAME ApplyFILT_1stOrderLag_usp
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
/* %%%-SFUNWIZ_defines_Changes_BEGIN --- EDIT HERE TO _END */

/* %%%-SFUNWIZ_defines_Changes_END --- EDIT HERE TO _BEGIN */
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
#include "simstruc.h"

enum {PARAM = 0, NUM_PARAMS};

#define PARAM_ARG ssGetSFcnParam(S, PARAM)

#define N_PAR 0

/* define error messages */
#define ERR_INVALID_SET_INPUT_DTYPE_CALL  \
              "Invalid call to mdlSetInputPortDataType"

#define ERR_INVALID_SET_OUTPUT_DTYPE_CALL \
              "Invalid call to mdlSetOutputPortDataType"

#define ERR_INVALID_DTYPE     "Invalid input or output port data type"

#define TRUE 1
        
#define FALSE 0
/*====================*
 * S-function methods *
 *====================*/
/* Function: mdlInitializeSizes ===============================================
 * Abstract:
 *   Setup sizes of the various vectors.
 */
static void mdlInitializeSizes(SimStruct *S)
{

    ssSetNumSFcnParams(S, N_PAR);
     if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {
	 return; /* Parameter mismatch will be reported by Simulink */
     }



    if (!ssSetNumInputPorts(S, 3)) return;
    /*Input Port 0 */
    ssSetInputPortWidth(S,  0, 1); /* */
    ssSetInputPortDataType(S, 0, DYNAMICALLY_TYPED);
    ssSetInputPortDirectFeedThrough(S, 0, TRUE);
    ssSetInputPortAcceptExprInRTW(S, 0, 1);
    ssSetInputPortOptimOpts(S, 0, SS_REUSABLE_AND_LOCAL);
    
    /*Input Port 1 */
    ssSetInputPortWidth(S,  1, 1); /* */
    ssSetInputPortDataType(S, 1, DYNAMICALLY_TYPED);
    ssSetInputPortDirectFeedThrough(S, 1, TRUE);
    ssSetInputPortAcceptExprInRTW(S, 1, 1);
    ssSetInputPortOptimOpts(S, 1, SS_REUSABLE_AND_LOCAL);

	/*Input Port 2 */
    ssSetInputPortWidth(S,  2, 1); /* */
    ssSetInputPortDataType(S, 2, DYNAMICALLY_TYPED);
    ssSetInputPortDirectFeedThrough(S, 2, TRUE);

    if (!ssSetNumOutputPorts(S, 1)) return;
    
    ssSetOutputPortWidth(S, 0, 1);
    ssSetOutputPortDataType(S, 0, DYNAMICALLY_TYPED);
    ssSetOutputPortComplexSignal(S, 0, COMPLEX_NO);
    ssSetOutputPortOptimOpts(S, 0, SS_REUSABLE_AND_LOCAL);
    ssSetOutputPortOutputExprInRTW(S, 0, 1);
    
    ssSetNumSampleTimes(S, 1);

    /* specify the sim state compliance to be same as a built-in block */
    ssSetSimStateCompliance(S, USE_DEFAULT_SIM_STATE);
    
    /* Take care when specifying exception free code - see sfuntmpl_doc.c */
    ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |
                     SS_OPTION_USE_TLC_WITH_ACCELERATOR | 
		     SS_OPTION_WORKS_WITH_CODE_REUSE));
}


/* Function: mdlInitializeSampleTimes =========================================
 * Abstract:
 *    Specifiy  the sample time.
 */
static void mdlInitializeSampleTimes(SimStruct *S)
{
    ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);
    ssSetOffsetTime( S, 0, FIXED_IN_MINOR_STEP_OFFSET );
    ssSetModelReferenceSampleTimeDefaultInheritance(S);
}

/* Function: mdlOutputs =======================================================
 *
*/
#define FIRST_BIT_PSTN (0x01)
#define LAST_BIT_PSTN (0x08)
#define MAXWORD 65535
static void mdlOutputs(SimStruct *S, int_T tid)
{
    InputPtrsType u0ptrs = ssGetInputPortSignalPtrs(S,0);
    InputPtrsType u1ptrs = ssGetInputPortSignalPtrs(S,1);
    InputPtrsType u2ptrs = ssGetInputPortSignalPtrs(S,2);
    
    DTypeId   y0DataType = ssGetOutputPortDataType(S, 0);
    
    switch(y0DataType)
    {
        case SS_UINT16:
        {
            uint16_T            *pY0  = (uint16_T *)ssGetOutputPortSignal(S,0);
            InputUInt16PtrsType  pU0  = (InputUInt16PtrsType)u0ptrs;
            InputUInt16PtrsType   pU1  = (InputUInt16PtrsType)u1ptrs;
            InputUInt16PtrsType  pU2  = (InputUInt16PtrsType)u2ptrs;
            uint32_T LfFILT_Result;
            uint16_T LfFILT_Old;
            uint16_T LfFILT_New, LfFILT_k_Coeff;
  
            LfFILT_Old = *pU0[0];
            LfFILT_New = *pU1[0];
            LfFILT_k_Coeff = *pU2[0];
            if ( (LfFILT_Old == LfFILT_New)
            || (LfFILT_k_Coeff == 0 ) )
            {
                LfFILT_Result = LfFILT_Old;
            }
            else if (LfFILT_New > LfFILT_Old)
            {
                LfFILT_Result= (LfFILT_New - LfFILT_Old); 
                if(LfFILT_Result < 0)
                {
                    LfFILT_Result = 0;
                }
                else if(LfFILT_Result > 65535)
                {
                    LfFILT_Result = 65535;
                }
                else
                {
                   /* Do Nothing */
                }
                    
                LfFILT_Result= (LfFILT_k_Coeff * LfFILT_Result * 0.0000152587890625);
                if(LfFILT_Result < 0)
                {
                    LfFILT_Result = 0;
                }
                else if(LfFILT_Result > 65535)
                {
                    LfFILT_Result = 65535;
                }
                else
                {
                   /* Do Nothing */
                }                
                if (LfFILT_Result == 0)
                  {
                    LfFILT_Result = 0x0001;  /* Force a change of 1 LSB */
                  }

                LfFILT_Result=  LfFILT_Old + LfFILT_Result;
            }
            else /* if (LfFILT_New < LfFILT_Old) */
            {
                LfFILT_Result= (LfFILT_Old - LfFILT_New);  
                if(LfFILT_Result < 0)
                {
                    LfFILT_Result = 0;
                }
                else if(LfFILT_Result > 65535)
                {
                    LfFILT_Result = 65535;
                }
                else
                {
                   /* Do Nothing */
                }                
                LfFILT_Result= ( LfFILT_k_Coeff * LfFILT_Result * 0.0000152587890625);
                if(LfFILT_Result < 0)
                {
                    LfFILT_Result = 0;
                }
                else if(LfFILT_Result > 65535)
                {
                    LfFILT_Result = 65535;
                }
                else
                {
                   /* Do Nothing */
                }                
                if (LfFILT_Result == 0)
                  {
                     LfFILT_Result = 0x0001;  /* Force a change of 1 LSB */
                  }

                LfFILT_Result= (LfFILT_Old - LfFILT_Result);
            } /* end if (LfFILT_Old > LfFILT_New) */

            pY0[0] = LfFILT_Result;
            break;
        }
        case SS_SINGLE:
        {
            real32_T            *pY0  = (real32_T *)ssGetOutputPortSignal(S,0);
            InputReal32PtrsType  pU0  = (InputReal32PtrsType)u0ptrs;
            InputReal32PtrsType  pU1  = (InputReal32PtrsType)u1ptrs;
            InputReal32PtrsType  pU2  = (InputReal32PtrsType)u2ptrs;
            real32_T LfFILT_Result;
            real32_T LfFILT_Old;
            real32_T LfFILT_New, LfFILT_k_Coeff;
  
            LfFILT_Old = *pU0[0];
            LfFILT_New = *pU1[0];
            LfFILT_k_Coeff = *pU2[0];
            if ( (LfFILT_Old == LfFILT_New)
            || (LfFILT_k_Coeff == 0 ) )
            {
                LfFILT_Result = LfFILT_Old;
            }
            else if (LfFILT_New > LfFILT_Old)
            {
                LfFILT_Result = (LfFILT_New - LfFILT_Old); 
        
                LfFILT_Result = (LfFILT_k_Coeff * LfFILT_Result);
            
                if (LfFILT_Result == 0)
                  {
                    LfFILT_Result = 1;  /* Force a change of 1 LSB */
                  }

                LfFILT_Result =  LfFILT_Old + LfFILT_Result;
            }
            else /* if (LfFILT_New < LfFILT_Old) */
            {
                LfFILT_Result = ( LfFILT_Old - LfFILT_New);
               
                LfFILT_Result = ( LfFILT_k_Coeff * LfFILT_Result);
              
                if (LfFILT_Result == 0)
                  {
                     LfFILT_Result = 1;  /* Force a change of 1 LSB */
                  }

                LfFILT_Result= (LfFILT_Old - LfFILT_Result);
            } /* end if (LfFILT_Old > LfFILT_New) */

            pY0[0] = LfFILT_Result;
            break;
        }
    }
}

/* Function: mdlTerminate =====================================================
 * Abstract:
 *    In this function, you should perform any actions that are necessary
 *    at the termination of a simulation.  For example, if memory was
 *    allocated in mdlStart, this is the place to free it.
 */
static void mdlTerminate(SimStruct *S)
{
}


#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */

#define MDL_SET_INPUT_PORT_DATA_TYPE

/* Function: mdlSetInputPortDataType ==========================================
 *    This routine is called with the candidate data type for a dynamically
 *    typed port.  If the proposed data type is acceptable, the routine should
 *    go ahead and set the actual port data type using ssSetInputPortDataType.
 *    If the data type is unacceptable an error should generated via
 *    ssSetErrorStatus.  Note that any other dynamically typed input or
 *    output ports whose data types are implicitly defined by virtue of knowing
 *    the data type of the given port can also have their data types set via 
 *    calls to ssSetInputPortDataType or ssSetOutputPortDataType.
 */
static void mdlSetInputPortDataType(SimStruct *S, 
                                    int       port, 
                                    DTypeId   dataType)
{
    if( ( port == 0 ) ) {
            /*
             * Accept proposed data type if it is an unsigned integer type
             * force all data ports to use this data type.
             */
            ssSetInputPortDataType(  S, 0, dataType );
			ssSetOutputPortDataType( S, 0, dataType );
			
       
    }else if(port == 1) {

                ssSetInputPortDataType(  S, 1, dataType );
    }else if(port == 2) {

                ssSetInputPortDataType(  S, 2, dataType );
    }
    else {
        /* 
         * Should not end up here.  Simulink will only call this function
         * for existing input ports whose data types are unknown.
         */
        ssSetErrorStatus(S, ERR_INVALID_SET_INPUT_DTYPE_CALL);
        goto EXIT_POINT;
    }

EXIT_POINT:
    return;
} /* mdlSetInputPortDataType */



#define MDL_SET_OUTPUT_PORT_DATA_TYPE
/* Function: mdlSetOutputPortDataType =========================================
 *    This routine is called with the candidate data type for a dynamically
 *    typed port.  If the proposed data type is acceptable, the routine should
 *    go ahead and set the actual port data type using ssSetOutputPortDataType.
 *    If the data tyoe is unacceptable an error should generated via
 *    ssSetErrorStatus.  Note that any other dynamically typed input or
 *    output ports whose data types are implicitly defined by virtue of knowing
 *    the data type of the given port can also have their data types set via 
 *    calls to ssSetInputPortDataType or ssSetOutputPortDataType.
 */
static void mdlSetOutputPortDataType(SimStruct *S, 
                                     int       port, 
                                     DTypeId   dataType)
{
    if ( port == 0 ) {
            /*
             * Accept proposed data type if it is an unsigned integer type
             * force all the ports to use this data type.
             */
           ssSetOutputPortDataType( S, 0, dataType );            
    }
    else {
        /* 
         * Should not end up here.  Simulink will only call this function
         * for existing output ports whose data types are unknown.  
         */
        ssSetErrorStatus(S, ERR_INVALID_SET_OUTPUT_DTYPE_CALL);
        goto EXIT_POINT;
    }

EXIT_POINT:
    return;

} /* mdlSetOutputPortDataType */


#define MDL_SET_DEFAULT_PORT_DATA_TYPES
/* Function: mdlSetDefaultPortDataTypes ========================================
 *    This routine is called when Simulink is not able to find data type 
 *    candidates for dynamically typed ports. This function must set the data 
 *    type of all dynamically typed ports.
 */
static void mdlSetDefaultPortDataTypes(SimStruct *S)
{
    /* Set input port data type to uint8 */
    ssSetInputPortDataType(  S, 0, SS_UINT16 );            
    ssSetInputPortDataType(  S, 1, SS_UINT16 );
	ssSetInputPortDataType(  S, 2, SS_UINT16 );
    ssSetOutputPortDataType( S, 0, SS_UINT16 );

} /* mdlSetDefaultPortDataTypes */

#endif /* MATLAB_MEX_FILE */


/*=======================================*
* Required closing for C MEX S-Function *
*=======================================*/

#ifdef    MATLAB_MEX_FILE  /* Is this file being compiled as a MEX-file? */
# include "simulink.c"     /* MEX-file interface mechanism               */
#else
# include "cg_sfun.h"      /* Code generation registration function      */
#endif


/* [EOF] sfun_dtype_io.c */


